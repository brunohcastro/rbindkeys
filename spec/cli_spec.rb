# -*- coding:utf-8; mode:ruby; -*-

require 'rbindkeys'
require 'revdev'

include Rbindkeys

describe CLI do
  describe '#.main' do
    context ', when ARGV is empty,' do
      before do
        @stdout = StringIO.new
        # stub(STDOUT){@stdout}
        ARGV = []
      end
      it 'shoud exit with code 1' do
        expect { CLI::main }.to raise_error do |e|
          e.should be_a SystemExit
          e.status.should == 1
        end
      end
    end
    context ', when ARGV have an argument,' do
      before do
        ARGV = ['foo']
        @observer = mock Observer
        Observer.should_receive(:new){@observer}
        @observer.should_receive(:start){nil}
      end
      it 'should call Observer#new ' do
        config = CLI::config
        CLI::main
        CLI::config.should == config
      end
    end
    context ', when ARGV have an option (--evdev-list)' do
      before do
        ARGV = ['--evdev-list']
        @evdev = mock Revdev::EventDevice
        @id = mock Object
        @evdev.stub(:device_name){"foo"}
        @evdev.stub(:device_id){@id}
        @id.stub(:hr_bustype){'bar'}
        Revdev::EventDevice.stub(:new){@evdev}
        Dir.should_receive(:glob).with(CLI::EVDEVS).
          and_return(['/dev/input/event4','/dev/input/event2',
                      '/dev/input/event13'])
        @stdout = StringIO.new
        $stdout = @stdout
      end
      it 'should pring device info' do
        CLI::main
        @stdout.string.should match(%r!^/dev/input/event2!)
      end
    end
    context ', when ARGV have an invalid option (--config)' do
      before do
        ARGV = ['--config']
      end
      it 'should exit with code 1' do
        expect { CLI::main }.to raise_error do |e|
          e.should be_a SystemExit
          e.status.should == 1
        end
      end
    end
    context ', when ARGV have an option (--config) and an event device' do
    end
  end
end
